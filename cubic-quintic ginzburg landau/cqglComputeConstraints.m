function constraints = cqglComputeConstraints(caseType, caseLetter)
% cqglComputeParams: Computes
% necessary constraints for the 2D cubic
% quintic ginzburg landau equation by
% caseType and caseLetter
%
% Synopsis: cqglComputeConstraints
%           cqglComputeConstraints(caseType, caseLetter):
%           
%
% Input:    caseType = the type of case
%           of interest. Case 1 (bright
%           -bright, front-front, and train solitrary waves),
%           Case 2 (Similar to case 1),
%           Case 3 (progressive bright-bright, train solitary waves,
%           front-front, dark-dark, W-dark-W dark waves)
%           Default: 1
%
%           caseLetter = The type of
%           wave of interest
%           Default: "A"
%
%
% Output:   result = structure comprised
%           of resulting constraints
if(nargin <= 1)
    caseType = 1;
    caseLetter = "A";
end

% --- Define constraints
if(caseType == 1)
   if(caseLetter == "B" || caseLetter == "b")
       constraints.omega_1 = @(v, k_1, R, gamma_1) ...
           v * k_1 - ((R^2) * imag(gamma_1))/4 + ((k_1^2) * imag(gamma_1));
       constraints.omega_2 = @(v, k_2, R, gamma_2) ...
           -(v * k_2) - ((R^2) * imag(gamma_2))/4 + ((k_2^2) * imag(gamma_2));
       constraints.R = @(chi_1, alpha_1, gamma_1) ...
           sqrt((chi_1)/(alpha_1 * imag(gamma_1)));
       constraints.w =  @(R, v, k_1,gamma_1, chi_1) ...
           -(R * v) - (2 * R * k_1 * imag(gamma_1)) + (2 * chi_1);
       constraints.k2 = @(R, v, k_1, gamma_1, chi_1, chi_2, gamma_2) ...
           ((R * v) +  (R*k_1 * imag(gamma_1)) - chi_1 + chi_2) / (R * imag(gamma_2));
       constraints.musq =  @(b, alpha_1, beta_1, chi_1, xi_1) ...
          (b * (-3 * alpha_1 * imag(beta_1) - real(beta_1) + ...
          2 * (alpha_1^2)*real(beta_1))*chi_1)/(alpha_1 * (real(beta_1) *imag(xi_1) - ...
          imag(beta_1) * real(xi_1)));
      constraints.nsq =  @(b, alpha_1, beta_1, chi_1, xi_1) ...
          (b * (3 * alpha_1 * imag(xi_1) - real(xi_1) + ...
          2 * (alpha_1^2)*real(xi_1))*chi_1)/(alpha_1 * (real(beta_1) *imag(xi_1) - ...
          imag(beta_1) * real(xi_1)));
      constraints.k1 = @(v, alpha_1, gamma_1, chi_1) ...
          (-v + sqrt(alpha_1 * imag(gamma_1) * chi_1)) / imag(gamma_1);
      constraints.chi2 = @(alpha_1, alpha_2, gamma_1, gamma_2, chi_1) ...
          (alpha_2 * imag(gamma_2) * chi_1) / (alpha_1 * imag(gamma_1));
      % --- Solve for the roots
      constraints.alpha = @cqglSolveForAlpha;
      
      % --- Solve for contraints
      constraints.gamma_1i = @(alpha_1, alpha_2, gamma_2, beta_1, xi_1, beta_2, xi_2) ...
          (3 * alpha_2 * imag(gamma_2)*(real(beta_1) * imag(xi_1) ...
          - imag(beta_1) * real(xi_1))) / ((-real(beta_1) * real(beta_2) ...
          + real(xi_1) * real(xi_2) + 3 * alpha_1 * (-imag(beta_1) * real(beta_2) ...
          + imag(xi_1) * real(xi_2)) + alpha_1^2 * (2 * real(beta_1) * real(beta_2) - ...
          2 * real(xi_1) * real(xi_2))));
      
      constraints.xi_2r = @(alpha_1, alpha_2, beta_2, beta_1, gamma_1, gamma_2, xi_1, delta_1, delta_2) ...
          -((-3 * alpha_1 * imag(beta_1) - real(beta_1) + 2 * alpha_1 * real(beta_1)) ...
          / (8 * imag(delta_1)* ((3 * alpha_1 * imag(xi_1) + real(xi_1) -  2 * alpha_1 ^ 2 * real(xi_1))^3))) ...
          * (-9 * real(beta_1)^2 * real(delta_2)*imag(xi_1) +  9 * imag(beta_1) * real(beta_1) * real(delta_2) * real(xi_1) + ...
          8 * real(beta_2) * imag(delta_1) * real(xi_1)^2 - ...
          12 * alpha_1^3 * (-3 * imag(beta_1) * real(beta_1)* real(delta_2)* imag(xi_1) + ...
          3 * imag(beta_1)^2 * real(delta_2) * real(xi_1) + 8 * real(beta_2) * imag(delta_1) * imag(xi_1) * real(xi_1) ...
          ) + 3 * alpha_1 * (-9 * imag(beta_1) * real(beta_1) * real(delta_2) * imag(xi_1) + 9 * imag(beta_1)^2 ...
          * real(delta_2) * real(xi_1) + 16 * real(beta_2) * imag(delta_1) * imag(xi_1) * real(xi_1) ...
          ) -  8 * alpha_1^4 * (3 * real(beta_1)^2 * real(delta_2) * imag(xi_1) - 3 * imag(beta_1)*real(beta_1)*real(delta_2)*real(xi_1) - ...
          4 * real(beta_2)*imag(delta_1)*real(xi_1)^2) + alpha_1^2*(30 * real(beta_1)^2 * real(delta_2)* imag(xi_1) - ...
          30 * imag(beta_1) * real(beta_1) * real(delta_2) * real(xi_1) + 8 * real(beta_2) * imag(delta_1) * (9 * imag(xi_1)^2 - ...
          4 * real(xi_1)^2)));
      constraints.xi_2i = @(alpha_1, alpha_2, beta_1, beta_2, gamma_1, gamma_2, xi_1) ...
          (alpha_1 * imag(beta_2) * imag(gamma_1) * (3 * imag(beta_1) - 2 * alpha_1 * real(beta_1)) + real(beta_1) * (imag(beta_2) * imag(gamma_1)-...
          (1-2*alpha_2^2)* imag(gamma_2)* imag(xi_1)) + (1 - 2 * alpha_2 ^ 2) * imag(beta_1) * imag(gamma_2)* real(xi_1)) / ...
          (imag(gamma_1)* (3 * alpha_1 * imag(xi_1) + real(xi_1) - 2 * alpha_1^2 * real(xi_1)));
      constraints.L = @(b, delta_1, xi_1, chi_1, alpha_1, beta_1) ...
          b^2 * (4 * imag(delta_1) * real(xi_1)^2 * chi_1 + 16 * alpha_1 ^ 4 * imag(delta_1) * real(xi_1)^2 * chi_1 + ...
          4 * alpha_1^2 * imag(delta_1) * (9 * imag(xi_1)^2 - 4 * real(xi_1)^2) * chi_1 + ...
          4 * alpha_1^3 * (real(beta_1)^2 * imag(xi_1)^2 - 2 * imag(beta_1) * real(beta_1)*imag(xi_1) * real(xi_1) + ...
          real(xi_1) * (imag(beta_1)^2 * real(xi_1) -  12 * imag(delta_1) * imag(xi_1) * chi_1)) - ...
          - 3 * alpha_1 * (real(beta_1)^2 * imag(xi_1)^2 - 2 * imag(beta_1) * real(beta_1) * imag(xi_1) * real(xi_1) + ...
          real(xi_1) * (imag(beta_1)^2 * real(xi_1) - 8 * imag(delta_1) * imag(xi_1) * chi_1))) / ...
          (4 * alpha_1 * (-3 + 4 * alpha_1 ^ 2) * (real(beta_1) * imag(xi_1) - imag(beta_1) * real(xi_1))^2);
   end
end

end

function [alpha_1, alpha_2] = cqglSolveForAlpha(delta_1, delta_2)
      p = [4*real(delta_1), -8*imag(delta_1),-3*real(delta_1)];
      alpha1_roots = roots(p);

      p = [4*real(delta_2),-8*imag(delta_2),-3*real(delta_2)];
      alpha2_roots = roots(p);

      alpha_1 = alpha1_roots(alpha1_roots < 0);
      alpha_2 = alpha2_roots(alpha2_roots < 0);
end




